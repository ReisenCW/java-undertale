# 代码重构报告：依赖注入模式实施

## 1. 重构概述
本次重构主要针对游戏架构中的“管理器（Manager）”层级和“场景（Scene）”层级。
* **重构前**：大量使用 `getInstance()` 获取单例对象，或直接调用 `Game.staticMethod()` 获取全局状态。类与类之间存在隐式、紧密的耦合。
* **重构后**：对象所需的依赖项（如 `Player`, `EnemyManager`, `UIManager`）通过构造函数显式传递。`Game` 类充当了“组合根（Composition Root）”的角色，负责实例化所有对象并将它们组装在一起。

---

## 2. 重点变更文件详解

### A. 核心架构层 (`Game.java`, `Main.java`)

* **Game.java**
    * **变更**：`Game` 类本身从纯静态工具类变为单例类（虽保留 `getInstance` 但用于内部状态持有）。
    * **初始化逻辑 (`init`)**：这是本次重构的枢纽。以前各个 Manager 自己初始化自己；现在 `Game` 负责按顺序 `new` 出 `EnemyManager`, `UIManager` 等，并将它们作为参数传递给需要它们的其他对象（如 `ObjectManager`, `SceneFactory`, `Renderer`）。
    * **Service Locator 模式**：保留了 `getRenderer()`, `getPlayer()` 等静态方法，但它们现在通过 `getInstance().field` 代理访问实例变量。这是一种过渡方案，既保留了访问便利性，又在内部实现了实例管理。

* **Main.java**
    * **变更**：启动方式从 `Game.run()` 变为 `Game.getInstance().run()`，适配了 `Game` 的实例化变更。

### B. 管理器层 (`EnemyManager`, `UIManager`, `ObjectManager`, `Renderer`)

这一层的改动最大，旨在**废除单例**。

* **EnemyManager.java & UIManager.java**
    * **移除**：删除了 `private static instance` 变量、私有构造函数和 `getInstance()` 方法。
    * **新增**：改为 `public` 构造函数，并接收必要的依赖（如 `Player`, `SoundManager`）。
    * **影响**：这两个管理器不再是全局唯一的“上帝对象”，它们的生命周期现在由 `Game` 类明确管理。

* **ObjectManager.java**
    * **变更**：构造函数新增 `EnemyManager` 参数。
    * **差异**：以前在 `init` 中直接调用 `EnemyManager.getInstance()`，现在直接使用传入的实例。

* **Renderer.java**
    * **变更**：构造函数参数大幅增加，不再在内部调用 `Game.getWindowWidth()` 或 `SceneManager.getInstance()`。
    * **差异**：所有的渲染上下文（Window, FontManager, SceneManager, 宽高）都在创建时注入。这使得 `Renderer` 成为一个纯粹的功能组件，不依赖于全局环境。

* **ScreenFadeManager.java**
    * **变更**：这是一个特殊的修改。它保留了 `getInstance()`，但增加了 `init(width, height)` 方法。
    * **原因**：可能是为了逐步迁移，或者是为了在某些无法传递参数的地方仍能访问它。但现在必须先由 `Game` 调用 `init` 后才能使用，避免了硬编码的依赖。

### C. 场景与工厂层 (`SceneFactory`, `Scene` 及子类)

* **SceneFactory.java**
    * **变更**：工厂类持有了更多的引用 (`UIManager`, `EnemyManager`)。
    * **作用**：在创建具体场景（如 `BattleFightScene`）时，工厂负责将这些引用注入进去。

* **具体场景类 (BattleFightScene, BattleMenuScene 等)**
    * **变更**：构造函数接收 `UIManager` 和 `EnemyManager`。
    * **差异**：不再在类成员变量声明时直接赋值 `EnemyManager.getInstance()`，而是在 `init` 或构造函数中通过参数赋值。

### D. 游戏实体与逻辑 (`Titan`, `Round*` 系列)

* **Titan.java**
    * **变更**：构造函数接收 `Player` 对象。
    * **差异**：以前泰坦（Titan）内部可能通过全局方法获取玩家位置，现在直接操作传入的 `Player` 实例。

* **Round (RoundSnake, RoundFinger 等)**
    * **变更**：所有的回合逻辑类现在都接收 `UIManager` 和/或 `EnemyManager`。
    * **差异**：战斗逻辑（如弹幕生成、回合结束检查）不再依赖隐式的全局单例。

---

## 3. 重构前后主要差异对比

| 特性 | 重构前 (Before) | 重构后 (After) |
| :--- | :--- | :--- |
| **依赖获取** | **拉取模式 (Pull)**：对象内部主动调用 `Manager.getInstance()` 获取依赖。 | **推送模式 (Push)**：依赖项通过构造函数由外部（Game/Factory）传入。 |
| **耦合度** | **高**：类与具体的单例实现紧密绑定，难以替换。 | **低**：类只依赖于传入的对象接口/实例，不关心对象来源。 |
| **初始化顺序** | **隐式/分散**：依赖静态代码块或第一次调用时的懒加载，顺序难以控制。 | **显式/集中**：在 `Game.init()` 中严格按顺序实例化（先 Player，再 Manager，再 Renderer）。 |
| **可测试性** | **差**：很难编写单元测试，因为无法Mock静态的单例方法。 | **好**：可以轻松传入 Mock/Stub 的 Manager 或 Player 对象进行测试。 |
| **生命周期** | **永久**：单例通常存活于整个程序运行期间，重置游戏状态困难（需要手动 reset 变量）。 | **可控**：`Game.destroy()` 可以彻底销毁对象图。重新 `new Game()` 即可获得全新的状态。 |

**Before Refactoring:**

![beforeDependencyInjection](img/beforeDependencyInjection.png)

**After Refactoring:**

![afterDependencyInjection](img/afterDependencyInjection.png)

---

## 4. 变更原因与收益分析

### 1. 解决依赖混乱与隐藏依赖
* **问题**：在重构前，看 `BattleFightScene` 的代码，你无法一眼看出它依赖了 `EnemyManager`，因为它隐藏在代码深处的 `getInstance()` 调用中。
* **收益**：重构后，通过查看构造函数签名 `BattleFightScene(..., EnemyManager)`，可以立即明确该类运行所需的所有外部资源。代码具有了**自文档化**的特性。

### 2. 集中化管理生命周期
* **问题**：多个单例之间的初始化顺序往往是导致空指针异常（NPE）的根源（例如：在 TextureManager 初始化前 Renderer 就尝试获取纹理）。
* **收益**：`Game.java` 现在清晰地展示了启动流程：Config -> Window -> Managers -> SceneFactory -> Renderer。这消除了“谁先初始化”的歧义。

### 3. 提升可维护性与扩展性
* **问题**：如果未来需要实现“双人模式”（两个 Player）或“多重战斗实例”，单例模式将成为巨大的阻碍，因为 `Player.getInstance()` 只能返回一个实例。
* **收益**：现在 `EnemyManager` 持有 `Player` 引用。如果需要，我们可以实例化两个 `EnemyManager`，分别给予不同的 `Player` 实例，互不干扰。

### 4. 为单元测试铺路
* 虽然代码中暂时未展示测试代码，但这种重构是编写高质量单元测试的先决条件。现在可以创建一个假的 `UIManager` 传入 `BattleFightScene` 来测试战斗逻辑，而无需启动整个图形界面。

## 5. 总结
本次重构将项目从**静态单例网状结构**转变为**层次化的对象树结构**。虽然代码量略有增加（主要是构造函数传参），但显著提升了系统的架构质量。`Game` 类现在承担了装配工的职责，而其他类则专注于自身的业务逻辑，不再关心“我在哪里”或“全局状态是什么”。这是一个非常正向且专业的架构演进。